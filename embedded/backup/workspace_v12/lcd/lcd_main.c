/*
  LCD
    @omzn  2020/10/20
*/

#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include "inc/hw_i2c.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_qei.h"
#include "inc/hw_timer.h"
#include "driverlib/rom.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/pwm.h"
#include "driverlib/timer.h"

#include "driverlib/qei.h"
#include "utils/uartstdio.h"
#include "utils/uartstdio.c" //strong-arm method

#include "periphConf.h" //generated by PinMux

#include "my_util.h"
#include "my_i2c.h"

#include "buzzer.h"
#include "lcd_SB1602.h"

//*****************************************************************************
// Global variables
//*****************************************************************************
uint8_t face1[]={SB1602_DATA_BURST,'(',0xF3,0xA5,'w',0xA5,0xF4,')'};
uint8_t face2[]={SB1602_DATA_BURST,'(',0xF4,0xA5,'w',0xA5,0xF3,')'};
uint8_t msg1[]= {SB1602_DATA_BURST,0xBC,0xAC,0xB7,0xB0,0xDD,'!'};
uint8_t msg2[]= {SB1602_DATA_BURST,0xBC,0xAE,0xCE,0xDE,'-',0xDD};

//*****************************************************************************
//
// This function sets up UART0 to be used for a console to display information
// as the example is running.
//
//*****************************************************************************
void initConsole(void) {
  // Enable GPIO port A which is used for UART0 pins.
  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
  // Configure the pin muxing for UART0 functions on port A0 and A1.
  // This step is not necessary if your part does not support pin muxing.
  GPIOPinConfigure(GPIO_PA0_U0RX);
  GPIOPinConfigure(GPIO_PA1_U0TX);
  // Enable UART0 so that we can configure the clock.
  SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
  // Use the internal 16MHz oscillator as the UART clock source.
  UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
  // Select the alternate (UART) function for these pins.
  GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
  // Initialize the UART for console I/O.
  UARTStdioConfig(0, 9600, 16000000);
}

void initInterruptPins(void) {
  // Clear Interrupt
  GPIOIntClear(GPIO_PORTF_BASE,INT_ALL_BUTTONS);

  // Register a handler function
  GPIOIntRegister(GPIO_PORTF_BASE,SW1PinIntHandler);

  // Set type of interrupt to falling edge
  GPIOIntTypeSet(GPIO_PORTF_BASE,INT_LEFT_BUTTON,GPIO_FALLING_EDGE);
}

//*****************************************************************************
// Event handers
//*****************************************************************************

void SysTickIntHandler(void) {
    static uint32_t led_color = LED_ALL;
    static uint32_t face = 0;
    static uint32_t tick_count = 0;
    //uint8_t command[16];
    if (tick_count % 16 == 0) {
        led_color = ~led_color;
        GPIOPinWrite(GPIO_PORTF_BASE,LED_GREEN,led_color);
        if (tick_count % 32 == 0) {
            tick_count = 0;

            //before
            //command[0] = SB1602_COMMAND_SINGLE;
            //command[1] = 0x80 | 0x04;
            //writeDataI2C(I2C3_BASE,SB1602_SLAVE_ADDRESS,command,2);

            //after
            setAddressLCD(4, 0);

            if (face == 0) {
                //writeDataI2C(I2C3_BASE,SB1602_SLAVE_ADDRESS,face1,8);
                writeTextLCD(&face1[1], 7);
            } else {
                //writeDataI2C(I2C3_BASE,SB1602_SLAVE_ADDRESS,face2,8);
                writeTextLCD(&face2[1], 7);
            }

            //before
            //command[0] = SB1602_COMMAND_SINGLE;
            //command[1] = 0x80 | 0x45;
            //writeDataI2C(I2C3_BASE,SB1602_SLAVE_ADDRESS,command,2);

            //after
            setAddressLCD(5, 1);

            if (face == 0) {
                //writeDataI2C(I2C3_BASE,SB1602_SLAVE_ADDRESS,msg1,7);
                writeTextLCD(&msg1[1], 6);
            } else {
                //writeDataI2C(I2C3_BASE,SB1602_SLAVE_ADDRESS,msg2,7);
                writeTextLCD(&msg2[1], 6);
            }
            face = 1 - face;
        }
    }
    tick_count++;
}

void SW1PinIntHandler(void) {
  SysTickIntDisable();
  disableSW1PinInt();
  clearSW1PinInt();

  static uint8_t spaces[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};

  setAddressLCD(0, 0);
  writeTextLCD(spaces,16);
  setAddressLCD(0, 1);
  writeTextLCD(spaces,16);

  static uint8_t counter[] = {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'};
  counter[15]++;

  uint8_t ptr;
  for(ptr = 15; ptr > 0; ptr--){
    if(counter[ptr] > '9') {
      counter[ptr] = '0';
      counter[ptr - 1]++;
    } else break;
  }

  if(counter[ptr] > '9') {
    for(ptr = 0; ptr < 15; ptr++) counter[ptr] = '0';
  }

  uint8_t head = 0;
  while(head < 15 && counter[head] == '0') head++;
  uint8_t counter_length = 16 - head;

  setAddressLCD(head, 0);
  writeTextLCD(&counter[head], counter_length);

  enableSW1PinInt();
}

int main(void) {
  // Set the clocking to run directly from the crystal.
  ROM_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
		     SYSCTL_XTAL_16MHZ);
  // Set up ports hardware (see periphConf.c)
  PortFunctionInit();

  // Set up interrupts (you can specify GPIO interrupt initialization here)
  initInterruptPins();
  enableSW1PinInt();

  // Initialize console
  initConsole();
  UARTprintf("LCD example\n");

  // Initialize buzzer
  initBuzzer();

  // Initialize two I2C Masters
  initI2C(I2C3_BASE);
  // Initialize LCD module
  initLCD();

  SysTickPeriodSet(SysCtlClockGet() / SYSTICKS_PER_SEC);
  SysTickEnable();
  SysTickIntRegister(SysTickIntHandler);
  SysTickIntEnable();

  while(1);
}

